<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üñçÔ∏è Nature Color Studio</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Patrick+Hand&display=swap');
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:#1a0a2e; font-family:'Fredoka One',cursive; overflow:hidden; height:100vh; display:flex; flex-direction:column; align-items:center; user-select:none; }
  body::before { content:''; position:fixed; top:0;left:0;right:0;bottom:0; background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.07) 2px,rgba(0,0,0,0.07) 4px); pointer-events:none; z-index:999; }
  #header { width:100%; background:linear-gradient(180deg,#4a1080,#7b20c0 50%,#4a1080); border-bottom:4px solid #ff6ec7; padding:6px 20px; display:flex; align-items:center; justify-content:space-between; box-shadow:0 4px 0 #2d0060,0 6px 20px rgba(0,0,0,0.5); position:relative; z-index:10; }
  #header::before { content:''; position:absolute; top:0;left:0;right:0; height:2px; background:linear-gradient(90deg,transparent,#ff6ec7,#fff,#ff6ec7,transparent); }
  .logo { display:flex; align-items:center; gap:10px; }
  .logo-icon { font-size:28px; animation:wiggle 3s ease-in-out infinite; }
  @keyframes wiggle { 0%,100%{transform:rotate(-5deg)}50%{transform:rotate(5deg)} }
  .logo-text { color:#fff; font-size:22px; text-shadow:2px 2px 0 #2d0060; letter-spacing:1px; }
  .logo-sub { color:#ffdd44; font-size:10px; letter-spacing:3px; text-transform:uppercase; font-family:'Patrick Hand',cursive; display:block; }
  .header-btns { display:flex; gap:10px; }
  .retro-btn { font-family:'Fredoka One',cursive; font-size:14px; padding:6px 16px; border:none; border-radius:6px; cursor:pointer; top:0; position:relative; }
  .retro-btn:active { top:3px; }
  .btn-new { background:linear-gradient(180deg,#ffe566,#f5a623); color:#5a2d00; box-shadow:0 4px 0 #a0620a; }
  .btn-clear { background:linear-gradient(180deg,#ff8888,#cc2222); color:#fff; box-shadow:0 4px 0 #880000; }
  #main { flex:1; display:flex; width:100%; overflow:hidden; position:relative; }
  #canvas-wrap { flex:1; display:flex; align-items:center; justify-content:center; background:radial-gradient(ellipse at 50% 30%,#2d1060,#0d0520); position:relative; overflow:hidden; }
  canvas { border:5px solid #7b20c0; box-shadow:0 0 0 2px #ff6ec7,0 0 0 6px #7b20c0,0 0 40px rgba(255,110,199,0.3); cursor:crosshair; display:block; }
  #bottom-tray { width:100%; background:linear-gradient(180deg,#0b1c3e,#162f5e 40%,#0b1c3e); border-top:4px solid #ff6ec7; box-shadow:0 -4px 0 #2d0060; padding:8px 16px 10px; display:flex; flex-direction:column; align-items:center; gap:6px; }
  #tray-label { color:#ffdd44; font-size:11px; letter-spacing:4px; text-transform:uppercase; font-family:'Patrick Hand',cursive; }
  #crayon-row { display:flex; gap:5px; align-items:flex-end; overflow-x:auto; padding-bottom:4px; }
  .crayon { width:28px; height:76px; cursor:pointer; flex-shrink:0; transition:transform 0.15s,filter 0.15s; }
  .crayon:hover { transform:translateY(-10px); filter:brightness(1.15); }
  .crayon.selected { transform:translateY(-14px); filter:brightness(1.2) drop-shadow(0 0 8px rgba(255,255,255,0.6)); }
  .crayon svg { width:100%; height:100%; display:block; }
  #selected-info { color:#fff; font-size:12px; font-family:'Patrick Hand',cursive; min-height:16px; letter-spacing:1px; }
  #loading { position:absolute; inset:0; background:rgba(10,0,30,0.92); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:20; gap:16px; transition:opacity 0.4s; }
  #loading.hidden { opacity:0; pointer-events:none; }
  .loading-text { color:#ffdd44; font-size:24px; animation:pulse 0.8s ease-in-out infinite alternate; }
  @keyframes pulse { from{opacity:0.5}to{opacity:1} }
  .loading-crayons { display:flex; gap:8px; }
  .lc { width:16px; height:48px; border-radius:3px; animation:bounce 0.6s ease-in-out infinite alternate; }
  .lc:nth-child(2){animation-delay:0.1s} .lc:nth-child(3){animation-delay:0.2s} .lc:nth-child(4){animation-delay:0.3s} .lc:nth-child(5){animation-delay:0.4s}
  @keyframes bounce { from{transform:translateY(0)}to{transform:translateY(-16px)} }
  #tooltip { position:fixed; background:rgba(0,0,0,0.85); color:#fff; font-family:'Patrick Hand',cursive; font-size:12px; padding:4px 10px; border-radius:4px; pointer-events:none; z-index:100; display:none; border:1px solid #ff6ec7; white-space:nowrap; }
</style>
</head>
<body>
<div id="header">
  <div class="logo">
    <span class="logo-icon">üñçÔ∏è</span>
    <div><span class="logo-text">Nature Color Studio</span><span class="logo-sub">Deluxe Edition</span></div>
  </div>
  <div class="header-btns">
    <button class="retro-btn btn-new" onclick="newPicture()">üåø New Picture</button>
    <button class="retro-btn btn-clear" onclick="clearColors()">üóëÔ∏è Clear Colors</button>
  </div>
</div>
<div id="main">
  <div id="canvas-wrap">
    <canvas id="canvas"></canvas>
    <div id="loading">
      <div class="loading-crayons">
        <div class="lc" style="background:#ff4444"></div><div class="lc" style="background:#ff9933"></div>
        <div class="lc" style="background:#ffdd00"></div><div class="lc" style="background:#33bb33"></div>
        <div class="lc" style="background:#3366ff"></div>
      </div>
      <div class="loading-text">Drawing your scene...</div>
    </div>
  </div>
</div>
<div id="bottom-tray">
  <div id="tray-label">‚ú¶ Pick a Crayon ‚ú¶</div>
  <div id="crayon-row"></div>
  <div id="selected-info">Click a crayon to begin coloring!</div>
</div>
<div id="tooltip"></div>

<script>
// =====================================================
// CRAYONS
// =====================================================
const CRAYONS = [
  {name:'Licorice',     hex:'#1a1a1a'},
  {name:'Night Blue',   hex:'#1c2a6e'},
  {name:'Royal Purple', hex:'#5b2d8e'},
  {name:'Plum',         hex:'#8b1a5a'},
  {name:'Cherry Red',   hex:'#d01010'},
  {name:'Brick Red',    hex:'#b83a2c'},
  {name:'Tangerine',    hex:'#e8660a'},
  {name:'Sunshine',     hex:'#f7d010'},
  {name:'Lemon Drop',   hex:'#f0f050'},
  {name:'Grass Green',  hex:'#1e8a1e'},
  {name:'Fern',         hex:'#4aaa30'},
  {name:'Mint Leaf',    hex:'#70dd88'},
  {name:'Cerulean',     hex:'#1a88d8'},
  {name:'Sky Blue',     hex:'#50b8f0'},
  {name:'Baby Blue',    hex:'#a0d8f8'},
  {name:'Aqua',         hex:'#20c8b8'},
  {name:'Pink Rose',    hex:'#f060a8'},
  {name:'Cotton Candy', hex:'#f8a8cc'},
  {name:'Peach',        hex:'#f0b888'},
  {name:'Tan',          hex:'#c8905a'},
  {name:'Chestnut',     hex:'#7a3e18'},
  {name:'Silver',       hex:'#b0b8c8'},
  {name:'Cloud White',  hex:'#f0f0f0'},
  {name:'Eraser',       hex:'#ffffff', isEraser:true},
];

function buildCrayons() {
  const row = document.getElementById('crayon-row');
  row.innerHTML = '';
  CRAYONS.forEach((c,i) => {
    const div = document.createElement('div');
    div.className = 'crayon' + (i===0?' selected':'');
    div.innerHTML = makeCrayonSVG(c.hex);
    div.addEventListener('click', () => selectCrayon(i));
    div.addEventListener('mouseenter', e => { const t=document.getElementById('tooltip'); t.textContent=c.name; t.style.display='block'; t.style.left=(e.clientX+12)+'px'; t.style.top=(e.clientY-28)+'px'; });
    div.addEventListener('mouseleave', () => { document.getElementById('tooltip').style.display='none'; });
    row.appendChild(div);
  });
}

function makeCrayonSVG(hex) {
  const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
  const L=`rgb(${Math.min(255,r+60)},${Math.min(255,g+60)},${Math.min(255,b+60)})`;
  const D=`rgb(${Math.max(0,r-50)},${Math.max(0,g-50)},${Math.max(0,b-50)})`;
  const T=`rgb(${Math.max(0,r-30)},${Math.max(0,g-30)},${Math.max(0,b-30)})`;
  const id=hex.slice(1);
  return `<svg viewBox="0 0 28 76" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="cg${id}" x1="0" x2="1"><stop offset="0%" stop-color="${D}"/><stop offset="25%" stop-color="${L}"/><stop offset="55%" stop-color="${hex}"/><stop offset="80%" stop-color="${D}"/><stop offset="100%" stop-color="${hex}"/></linearGradient>
    <linearGradient id="wr${id}" x1="0" x2="1"><stop offset="0%" stop-color="rgba(0,0,0,0.25)"/><stop offset="30%" stop-color="rgba(255,255,255,0.18)"/><stop offset="60%" stop-color="rgba(0,0,0,0.1)"/><stop offset="100%" stop-color="rgba(0,0,0,0.22)"/></linearGradient>
  </defs>
  <polygon points="14,0 4,22 24,22" fill="${T}"/>
  <polygon points="14,2 8,22 20,22" fill="${T}"/>
  <rect x="4" y="22" width="20" height="50" rx="2" fill="url(#cg${id})"/>
  <rect x="4" y="22" width="20" height="50" rx="2" fill="url(#wr${id})"/>
  <rect x="4" y="36" width="20" height="14" fill="rgba(255,255,255,0.12)"/>
  <rect x="4" y="36" width="20" height="1" fill="rgba(255,255,255,0.3)"/>
  <rect x="8" y="24" width="4" height="44" rx="2" fill="rgba(255,255,255,0.12)"/>
  <rect x="4" y="70" width="20" height="4" rx="1" fill="${D}"/>
</svg>`;
}

let selectedIdx = 0;
function selectCrayon(i) {
  selectedIdx = i;
  document.querySelectorAll('.crayon').forEach((el,j) => el.classList.toggle('selected', j===i));
  const c = CRAYONS[i];
  document.getElementById('selected-info').textContent = c.isEraser ? 'üßπ Eraser selected' : `üñçÔ∏è ${c.name} selected`;
}

// =====================================================
// CANVAS ‚Äî single canvas approach
// We draw everything onto ONE canvas.
// We keep a separate offscreen "lines only" canvas
// purely as a barrier reference for flood fill.
// =====================================================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', {willReadFrequently: true});

// Offscreen canvas holds ONLY the black outlines (barrier reference)
let linesCanvas, linesCtx;
// Offscreen canvas holds ONLY the fill colors
let fillCanvas, fillCtx;

let W = 800, H = 560;

function initCanvas() {
  const wrap = document.getElementById('canvas-wrap');
  W = Math.min(Math.floor(wrap.clientWidth - 40), 800);
  H = Math.min(Math.floor(wrap.clientHeight - 20), 560);
  canvas.width = W;
  canvas.height = H;

  linesCanvas = document.createElement('canvas');
  linesCanvas.width = W; linesCanvas.height = H;
  linesCtx = linesCanvas.getContext('2d', {willReadFrequently: true});

  fillCanvas = document.createElement('canvas');
  fillCanvas.width = W; fillCanvas.height = H;
  fillCtx = fillCanvas.getContext('2d', {willReadFrequently: true});
}

// Redraw the main canvas from fill + lines layers
function redraw() {
  // White background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, W, H);
  // Color fills underneath
  ctx.drawImage(fillCanvas, 0, 0);
  // Black outlines on top
  ctx.drawImage(linesCanvas, 0, 0);
}

// =====================================================
// SHAPE HELPER
// Draws a closed shape: white fill + black stroke
// onto BOTH linesCanvas (outline only) and fillCanvas (white fill only)
// =====================================================
const OUTLINE_COLOR = '#111111';
const LINE_W = 2.8;

function S(fn) {
  // Draw white fill on fillCanvas
  fillCtx.beginPath();
  fn(fillCtx);
  fillCtx.fillStyle = '#ffffff';
  fillCtx.fill();

  // Draw black outline on linesCanvas
  linesCtx.beginPath();
  fn(linesCtx);
  linesCtx.strokeStyle = OUTLINE_COLOR;
  linesCtx.lineWidth = LINE_W;
  linesCtx.lineJoin = 'round';
  linesCtx.lineCap = 'round';
  linesCtx.stroke();
}

// =====================================================
// SEEDED RNG
// =====================================================
let seed = 1;
function reseed() { seed = (Math.random() * 99999 | 0) + 1; }
function sr() { seed = (seed * 1664525 + 1013904223) & 0x7fffffff; return seed / 0x7fffffff; }

// =====================================================
// DRAWING PRIMITIVES
// =====================================================
function drawSkyBand(h) {
  S(c => { c.rect(0, 0, W, h); });
}
function drawGroundBand(y) {
  S(c => { c.rect(0, y, W, H - y); });
}
function drawHill(x, y, rx, ry) {
  S(c => { c.moveTo(x-rx,y); c.ellipse(x,y,rx,ry,0,Math.PI,0,false); c.closePath(); });
}
function drawSun(x, y, r) {
  const rays = 10;
  for (let i = 0; i < rays; i++) {
    const a=(i/rays)*Math.PI*2, a1=a-0.2, a2=a+0.2;
    S(c => { c.moveTo(x+Math.cos(a)*(r+24),y+Math.sin(a)*(r+24)); c.lineTo(x+Math.cos(a1)*(r+4),y+Math.sin(a1)*(r+4)); c.lineTo(x+Math.cos(a2)*(r+4),y+Math.sin(a2)*(r+4)); c.closePath(); });
  }
  S(c => { c.arc(x,y,r,0,Math.PI*2); });
}
function drawCloud(x, y) {
  S(c => {
    const cx=x, cy=y;
    c.moveTo(cx, cy+18);
    c.bezierCurveTo(cx-2,cy+28, cx+18,cy+30, cx+28,cy+26);
    c.bezierCurveTo(cx+38,cy+30, cx+58,cy+30, cx+68,cy+26);
    c.bezierCurveTo(cx+80,cy+30, cx+100,cy+26, cx+100,cy+14);
    c.bezierCurveTo(cx+106,cy+14, cx+112,cy+2, cx+100,cy-4);
    c.bezierCurveTo(cx+104,cy-22, cx+86,cy-36, cx+70,cy-26);
    c.bezierCurveTo(cx+66,cy-46, cx+42,cy-48, cx+36,cy-30);
    c.bezierCurveTo(cx+26,cy-44, cx+4,cy-38, cx+4,cy-20);
    c.bezierCurveTo(cx-8,cy-18, cx-8,cy+8, cx,cy+18);
    c.closePath();
  });
}
function drawRoundTree(x, gy, cr, th) {
  const tw=cr*0.28;
  S(c => { c.rect(x-tw/2, gy-th, tw, th); });
  S(c => { c.arc(x, gy-th-cr*0.55, cr, 0, Math.PI*2); });
}
function drawPineTree(x, gy, h) {
  const tw=h*0.08, trh=h*0.2;
  S(c => { c.rect(x-tw/2, gy-trh, tw, trh); });
  for (let t=0; t<3; t++) {
    const ty=gy-trh-t*(h*0.26), tw2=h*(0.36-t*0.06);
    S(c => { c.moveTo(x,ty-h*0.26); c.lineTo(x+tw2,ty); c.lineTo(x-tw2,ty); c.closePath(); });
  }
}
function drawFlower(x, y, r, np) {
  np = np||6;
  S(c => { c.moveTo(x-3,y+r*0.55); c.lineTo(x+3,y+r*0.55); c.lineTo(x+3,y+r*0.55+34); c.lineTo(x-3,y+r*0.55+34); c.closePath(); });
  for (let i=0; i<np; i++) { const a=(i/np)*Math.PI*2; S(c => { c.ellipse(x+Math.cos(a)*r*0.72, y+Math.sin(a)*r*0.72, r*0.4, r*0.26, a, 0, Math.PI*2); }); }
  S(c => { c.arc(x,y,r*0.34,0,Math.PI*2); });
}
function drawButterfly(x, y, sz) {
  S(c => { c.ellipse(x-sz*0.52,y-sz*0.28,sz*0.46,sz*0.32,-0.4,0,Math.PI*2); });
  S(c => { c.ellipse(x+sz*0.52,y-sz*0.28,sz*0.46,sz*0.32, 0.4,0,Math.PI*2); });
  S(c => { c.ellipse(x-sz*0.36,y+sz*0.24,sz*0.3, sz*0.2,  0.3,0,Math.PI*2); });
  S(c => { c.ellipse(x+sz*0.36,y+sz*0.24,sz*0.3, sz*0.2, -0.3,0,Math.PI*2); });
  S(c => { c.ellipse(x,y,sz*0.1,sz*0.48,0,0,Math.PI*2); });
}
function drawBird(x, y, sz) {
  S(c => { c.moveTo(x,y); c.quadraticCurveTo(x-sz*0.6,y-sz*0.85,x-sz*1.1,y); c.quadraticCurveTo(x-sz*0.6,y+sz*0.28,x,y); c.closePath(); });
  S(c => { c.moveTo(x,y); c.quadraticCurveTo(x+sz*0.6,y-sz*0.85,x+sz*1.1,y); c.quadraticCurveTo(x+sz*0.6,y+sz*0.28,x,y); c.closePath(); });
}
function drawRainbow(cx, cy, r0, bw) {
  for (let i=0; i<6; i++) {
    const r1=r0+i*bw, r2=r1+bw;
    S(c => { c.arc(cx,cy,r2,Math.PI,0,false); c.arc(cx,cy,r1,0,Math.PI,true); c.closePath(); });
  }
}
function drawMountain(x1, x2, px, py, gy) {
  S(c => { c.moveTo(x1,gy); c.lineTo(px,py); c.lineTo(x2,gy); c.closePath(); });
}
function drawSnowCap(px, py, w) {
  S(c => { c.moveTo(px,py); c.lineTo(px-w,py+w*1.3); c.lineTo(px+w,py+w*1.3); c.closePath(); });
}
function drawRabbit(x, gy) {
  S(c => { c.ellipse(x,gy-24,20,26,0,0,Math.PI*2); });
  S(c => { c.ellipse(x+6,gy-60,16,18,0.2,0,Math.PI*2); });
  S(c => { c.ellipse(x-3,gy-86,6,18,-0.2,0,Math.PI*2); });
  S(c => { c.ellipse(x+12,gy-84,6,18, 0.2,0,Math.PI*2); });
  S(c => { c.arc(x-19,gy-26,8,0,Math.PI*2); });
  S(c => { c.arc(x+10,gy-62,3,0,Math.PI*2); });
}
function drawMushroom(x, y, sz) {
  S(c => { c.rect(x-sz*0.18, y-sz*0.42, sz*0.36, sz*0.42); });
  S(c => { c.arc(x,y-sz*0.42,sz*0.5,Math.PI,0); c.closePath(); });
  S(c => { c.arc(x-sz*0.14,y-sz*0.6,sz*0.09,0,Math.PI*2); });
  S(c => { c.arc(x+sz*0.18,y-sz*0.55,sz*0.09,0,Math.PI*2); });
}
function drawStarfish(x, y, r) {
  S(c => { for (let i=0;i<5;i++) { const a=(i/5)*Math.PI*2-Math.PI/2, ai=a+Math.PI/5; if(i===0)c.moveTo(x+Math.cos(a)*r,y+Math.sin(a)*r); else c.lineTo(x+Math.cos(a)*r,y+Math.sin(a)*r); c.lineTo(x+Math.cos(ai)*r*0.42,y+Math.sin(ai)*r*0.42); } c.closePath(); });
}
function drawShell(x, y, r) {
  S(c => { c.moveTo(x-r,y); c.arc(x,y,r,Math.PI,0); c.closePath(); });
  S(c => { c.moveTo(x-r*0.65,y); c.arc(x,y,r*0.65,Math.PI,0); c.closePath(); });
  S(c => { c.moveTo(x-r*0.3,y); c.arc(x,y,r*0.3,Math.PI,0); c.closePath(); });
}
function drawPalmTree(x, gy) {
  const h=115;
  S(c => { c.moveTo(x-8,gy); c.quadraticCurveTo(x-14,gy-h*0.5,x+8,gy-h); c.lineTo(x+16,gy-h); c.quadraticCurveTo(x+4,gy-h*0.5,x+8,gy); c.closePath(); });
  const bx=x+10, by=gy-h;
  for (let l=0; l<5; l++) {
    const a=-Math.PI*0.72+l*Math.PI*0.36;
    S(c => { c.moveTo(bx,by); c.quadraticCurveTo(bx+Math.cos(a)*36+Math.cos(a+Math.PI/2)*16,by+Math.sin(a)*36+Math.sin(a+Math.PI/2)*16,bx+Math.cos(a)*72,by+Math.sin(a)*50); c.quadraticCurveTo(bx+Math.cos(a)*36-Math.cos(a+Math.PI/2)*16,by+Math.sin(a)*36-Math.sin(a+Math.PI/2)*16,bx,by); c.closePath(); });
  }
}
function drawCrab(cx, cy) {
  S(c => { c.ellipse(cx,cy,26,16,0,0,Math.PI*2); });
  S(c => { c.ellipse(cx-48,cy-16,12,9,0.4,0,Math.PI*2); });
  S(c => { c.ellipse(cx+48,cy-16,12,9,-0.4,0,Math.PI*2); });
  S(c => { c.moveTo(cx-24,cy-4);c.lineTo(cx-32,cy-14);c.lineTo(cx-38,cy-18);c.lineTo(cx-30,cy-8);c.closePath(); });
  S(c => { c.moveTo(cx+24,cy-4);c.lineTo(cx+32,cy-14);c.lineTo(cx+38,cy-18);c.lineTo(cx+30,cy-8);c.closePath(); });
  for (let j=0;j<3;j++) {
    S(c => { const lx=cx-8-j*6; c.moveTo(lx,cy+12);c.lineTo(lx-4,cy+12);c.lineTo(lx-10-j*4,cy+30);c.lineTo(lx-6-j*4,cy+30);c.closePath(); });
    S(c => { const lx=cx+8+j*6; c.moveTo(lx,cy+12);c.lineTo(lx+4,cy+12);c.lineTo(lx+10+j*4,cy+30);c.lineTo(lx+6+j*4,cy+30);c.closePath(); });
  }
  S(c => { c.arc(cx-10,cy-13,4,0,Math.PI*2); });
  S(c => { c.arc(cx+10,cy-13,4,0,Math.PI*2); });
}
function drawSunflower(x, gy, sz) {
  const sh=sz*2.7;
  S(c => { c.moveTo(x-4,gy);c.lineTo(x+4,gy);c.lineTo(x+4,gy-sh);c.lineTo(x-4,gy-sh);c.closePath(); });
  S(c => { c.ellipse(x+22,gy-sh*0.55,22,10,0.5,0,Math.PI*2); });
  for (let i=0;i<12;i++) { const a=(i/12)*Math.PI*2; S(c => { c.ellipse(x+Math.cos(a)*sz*0.72,gy-sh+Math.sin(a)*sz*0.72,sz*0.28,sz*0.16,a,0,Math.PI*2); }); }
  S(c => { c.arc(x,gy-sh,sz*0.38,0,Math.PI*2); });
}
function drawPicket(x, y, w, h) {
  S(c => { c.moveTo(x+w/2,y-14);c.lineTo(x,y);c.lineTo(x,y+h);c.lineTo(x+w,y+h);c.lineTo(x+w,y);c.closePath(); });
}
function drawBee(x, y) {
  S(c => { c.ellipse(x,y,11,7,0,0,Math.PI*2); });
  S(c => { c.moveTo(x-2,y-7);c.lineTo(x+3,y-7);c.lineTo(x+3,y+7);c.lineTo(x-2,y+7);c.closePath(); });
  S(c => { c.ellipse(x-4,y-11,8,4,-0.3,0,Math.PI*2); });
  S(c => { c.ellipse(x+6,y-11,8,4, 0.3,0,Math.PI*2); });
}
function drawWateringCan(x, y) {
  S(c => { c.rect(x,y-34,38,28); });
  S(c => { c.moveTo(x+38,y-28);c.quadraticCurveTo(x+62,y-38,x+60,y-14);c.lineTo(x+54,y-14);c.quadraticCurveTo(x+56,y-32,x+34,y-24);c.closePath(); });
  S(c => { c.moveTo(x+8,y-34);c.quadraticCurveTo(x+12,y-52,x+28,y-50);c.lineTo(x+30,y-44);c.quadraticCurveTo(x+16,y-44,x+14,y-32);c.closePath(); });
}
function drawWaveBand(y, bh) {
  S(c => {
    c.moveTo(0,y);
    for (let x=0; x<=W+52; x+=52) c.quadraticCurveTo(x+26,y-16,x+52,y);
    c.lineTo(W,y+bh); c.lineTo(0,y+bh); c.closePath();
  });
}

// =====================================================
// SCENES
// =====================================================
function generateScene() {
  reseed();
  linesCtx.clearRect(0,0,W,H);
  fillCtx.clearRect(0,0,W,H);
  // Fill fillCanvas with white so flood fill has a consistent starting color
  fillCtx.fillStyle = '#ffffff';
  fillCtx.fillRect(0,0,W,H);

  const n = Math.floor(sr() * 5);
  [drawForestScene,drawBeachScene,drawMeadowScene,drawMountainScene,drawGardenScene][n]();
  redraw();
}

function drawForestScene() {
  const gy=H*0.65;
  drawSkyBand(gy); drawGroundBand(gy);
  drawSun(W*0.85,H*0.1,38); drawCloud(W*0.04,22); drawCloud(W*0.42,12);
  drawHill(W*0.2,gy+8,200,68); drawHill(W*0.78,gy+8,165,55);
  [0.1,0.28,0.5,0.7,0.88].forEach(p => {
    const tx=W*p+(sr()-0.5)*25;
    sr()>0.45 ? drawRoundTree(tx,gy,52+sr()*28,52+sr()*18) : drawPineTree(tx,gy,100+sr()*45);
  });
  drawMushroom(W*0.2,gy,32); drawMushroom(W*0.62,gy,26);
  [0.06,0.17,0.29,0.4,0.52,0.63,0.75].forEach(p => drawFlower(W*p,gy+8+sr()*28,14+sr()*8,6));
  drawButterfly(W*0.34,H*0.29,22); drawButterfly(W*0.6,H*0.18,19);
  drawBird(W*0.25,H*0.11,13); drawBird(W*0.55,H*0.07,10); drawBird(W*0.72,H*0.14,11);
}
function drawBeachScene() {
  const gy=H*0.6, wY=H*0.48;
  drawSkyBand(wY); drawWaveBand(wY,(gy-wY)*0.48); drawWaveBand(wY+(gy-wY)*0.44,(gy-wY)*0.56); drawGroundBand(gy);
  drawSun(W*0.12,H*0.1,40); drawCloud(W*0.38,18); drawCloud(W*0.66,8);
  drawBird(W*0.28,H*0.08,11); drawBird(W*0.5,H*0.05,9); drawBird(W*0.72,H*0.1,10);
  drawPalmTree(W*0.78,gy); drawCrab(W*0.3,gy+28);
  drawStarfish(W*0.55,gy+20,20); drawStarfish(W*0.16,gy+36,15);
  drawShell(W*0.44,gy+28,18); drawShell(W*0.68,gy+22,14); drawShell(W*0.08,gy+20,16);
  drawButterfly(W*0.5,H*0.3,20);
}
function drawMeadowScene() {
  const gy=H*0.63;
  drawSkyBand(gy); drawGroundBand(gy);
  drawSun(W*0.5,H*0.07,46); drawCloud(W*0.07,18); drawCloud(W*0.56,26);
  drawHill(W*0.16,gy+12,240,85); drawHill(W*0.84,gy+12,190,72);
  drawRainbow(W*0.76,gy+18,82,14);
  [0.05,0.15,0.26,0.36,0.46,0.57,0.67,0.78,0.88,0.96].forEach(p => drawFlower(W*p,gy+8+sr()*26,16+sr()*8,6));
  drawRabbit(W*0.36,gy);
  drawButterfly(W*0.55,H*0.22,24); drawButterfly(W*0.18,H*0.35,19); drawButterfly(W*0.78,H*0.28,21);
  drawBird(W*0.42,H*0.08,12); drawBird(W*0.62,H*0.06,10);
  drawRoundTree(W*0.06,gy,48,48); drawRoundTree(W*0.94,gy,46,46);
}
function drawMountainScene() {
  const gy=H*0.63;
  drawSkyBand(gy); drawGroundBand(gy);
  drawSun(W*0.88,H*0.07,36); drawCloud(W*0.1,28); drawCloud(W*0.44,16);
  [{cx:W*0.18,py:H*0.2,w:200},{cx:W*0.44,py:H*0.1,w:260},{cx:W*0.68,py:H*0.19,w:210},{cx:W*0.9,py:H*0.27,w:180}].forEach(m => {
    drawMountain(m.cx-m.w/2,m.cx+m.w/2,m.cx,m.py,gy); drawSnowCap(m.cx,m.py,28);
  });
  drawPineTree(W*0.08,gy,95); drawPineTree(W*0.2,gy,110); drawPineTree(W*0.76,gy,100); drawPineTree(W*0.9,gy,88);
  S(c => { c.ellipse(W*0.5,gy+(H-gy)*0.52,W*0.22,(H-gy)*0.22,0,0,Math.PI*2); });
  [0.1,0.22,0.35,0.47,0.6,0.7,0.82].forEach(p => drawFlower(W*p,gy+12+sr()*18,12+sr()*6,5));
  drawBird(W*0.48,H*0.15,14); drawBird(W*0.32,H*0.1,10); drawBird(W*0.62,H*0.09,11);
}
function drawGardenScene() {
  const gy=H*0.66;
  drawSkyBand(gy); drawGroundBand(gy);
  drawSun(W*0.16,H*0.1,38); drawCloud(W*0.47,20); drawCloud(W*0.75,12);
  for (let fx=20; fx<W-20; fx+=44) drawPicket(fx,gy-52,20,52);
  [0.1,0.28,0.48,0.67,0.85].forEach(p => drawSunflower(W*p+(sr()-0.5)*18,gy,22+sr()*10));
  drawBee(W*0.2,H*0.24); drawBee(W*0.45,H*0.17); drawBee(W*0.72,H*0.3);
  [0.06,0.18,0.36,0.54,0.72,0.9].forEach(p => drawFlower(W*p,gy+14+sr()*18,10+sr()*6,5));
  drawButterfly(W*0.38,H*0.2,21); drawButterfly(W*0.6,H*0.35,18);
  drawWateringCan(W*0.03,gy-8);
  drawBird(W*0.5,H*0.07,11); drawBird(W*0.68,H*0.1,9);
}

// =====================================================
// FLOOD FILL
// Simple and reliable: reads directly from main canvas,
// fills directly onto fillCanvas, re-composites.
// =====================================================
function floodFill(startX, startY, fillHex) {
  // Parse target fill color
  const fr = parseInt(fillHex.slice(1,3),16);
  const fg = parseInt(fillHex.slice(3,5),16);
  const fb = parseInt(fillHex.slice(5,7),16);

  // Read from the main visible canvas ‚Äî what the user actually sees
  const imgData = ctx.getImageData(0, 0, W, H);
  const pix = imgData.data;

  // Also read fill layer to write back to
  const fillImg = fillCtx.getImageData(0, 0, W, H);
  const fillPix = fillImg.data;

  const i0 = (startY * W + startX) * 4;

  // Target color = what's visible at click point
  const tR = pix[i0], tG = pix[i0+1], tB = pix[i0+2];

  // Nothing to do if already this color
  if (tR === fr && tG === fg && tB === fb) return;

  // Helper: is this pixel close enough to the target color?
  function matchTarget(i) {
    return Math.abs(pix[i]  -tR) <= 24 &&
           Math.abs(pix[i+1]-tG) <= 24 &&
           Math.abs(pix[i+2]-tB) <= 24;
  }

  // Helper: is this pixel a dark outline on the lines layer?
  // We check the VISIBLE pixel ‚Äî outlines are dark (< 80 on all channels)
  function isOutline(i) {
    return pix[i] < 80 && pix[i+1] < 80 && pix[i+2] < 80;
  }

  // Don't start on an outline
  if (isOutline(i0)) return;

  // BFS flood fill
  const visited = new Uint8Array(W * H);
  const queue = [startX, startY];
  visited[startY * W + startX] = 1;
  let head = 0;

  while (head < queue.length) {
    const x = queue[head++];
    const y = queue[head++];
    const i = (y * W + x) * 4;

    if (isOutline(i)) continue;

    // Paint this pixel on the fill layer
    fillPix[i]   = fr;
    fillPix[i+1] = fg;
    fillPix[i+2] = fb;
    fillPix[i+3] = 255;

    // Check 4 neighbors
    const right=x+1, left=x-1, down=y+1, up=y-1;
    if (right < W) { const vi=y*W+right; if (!visited[vi] && matchTarget((y*W+right)*4)) { visited[vi]=1; queue.push(right,y); } }
    if (left  >=0) { const vi=y*W+left;  if (!visited[vi] && matchTarget((y*W+left) *4)) { visited[vi]=1; queue.push(left, y); } }
    if (down < H)  { const vi=down*W+x;  if (!visited[vi] && matchTarget((down*W+x) *4)) { visited[vi]=1; queue.push(x,down);  } }
    if (up   >=0)  { const vi=up*W+x;    if (!visited[vi] && matchTarget((up*W+x)   *4)) { visited[vi]=1; queue.push(x,up);    } }
  }

  fillCtx.putImageData(fillImg, 0, 0);
  redraw();
}

// =====================================================
// EVENTS
// =====================================================
canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width;
  const scaleY = H / rect.height;
  const x = Math.floor((e.clientX - rect.left) * scaleX);
  const y = Math.floor((e.clientY - rect.top)  * scaleY);
  if (x < 0 || y < 0 || x >= W || y >= H) return;
  const color = CRAYONS[selectedIdx].isEraser ? '#ffffff' : CRAYONS[selectedIdx].hex;
  canvas.style.cursor = 'wait';
  setTimeout(() => { floodFill(x, y, color); canvas.style.cursor = 'crosshair'; }, 10);
});

function newPicture() {
  document.getElementById('loading').classList.remove('hidden');
  setTimeout(() => {
    generateScene();
    setTimeout(() => document.getElementById('loading').classList.add('hidden'), 300);
  }, 200);
}

function clearColors() {
  fillCtx.fillStyle = '#ffffff';
  fillCtx.fillRect(0, 0, W, H);
  redraw();
}

// =====================================================
// INIT
// =====================================================
window.addEventListener('load', () => {
  buildCrayons();
  initCanvas();
  selectCrayon(0);
  newPicture();
});
window.addEventListener('resize', () => { initCanvas(); generateScene(); });
</script>
</body>
</html>
