<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üñçÔ∏è Nature Color Studio</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Patrick+Hand&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #1a0a2e;
    font-family: 'Fredoka One', cursive;
    overflow: hidden;
    height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
  }

  body::before {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.07) 2px, rgba(0,0,0,0.07) 4px);
    pointer-events: none;
    z-index: 999;
  }

  #header {
    width: 100%;
    background: linear-gradient(180deg, #4a1080 0%, #7b20c0 50%, #4a1080 100%);
    border-bottom: 4px solid #ff6ec7;
    padding: 6px 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-shadow: 0 4px 0 #2d0060, 0 6px 20px rgba(0,0,0,0.5);
    position: relative;
    z-index: 10;
  }

  #header::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 2px;
    background: linear-gradient(90deg, transparent, #ff6ec7, #fff, #ff6ec7, transparent);
  }

  .logo { display: flex; align-items: center; gap: 10px; }
  .logo-icon { font-size: 28px; filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.5)); animation: wiggle 3s ease-in-out infinite; }
  @keyframes wiggle { 0%,100% { transform: rotate(-5deg); } 50% { transform: rotate(5deg); } }
  .logo-text { color: #fff; font-size: 22px; text-shadow: 2px 2px 0 #2d0060, 4px 4px 0 rgba(0,0,0,0.3); letter-spacing: 1px; }
  .logo-sub { color: #ffdd44; font-size: 10px; letter-spacing: 3px; text-transform: uppercase; font-family: 'Patrick Hand', cursive; display: block; text-shadow: 1px 1px 0 #2d0060; }

  .header-btns { display: flex; gap: 10px; align-items: center; }

  .retro-btn {
    font-family: 'Fredoka One', cursive;
    font-size: 14px; padding: 6px 16px; border: none; border-radius: 6px;
    cursor: pointer; position: relative; transition: transform 0.1s, top 0.1s; top: 0; letter-spacing: 0.5px;
  }
  .retro-btn:active { top: 3px; }
  .btn-new { background: linear-gradient(180deg, #ffe566, #f5a623); color: #5a2d00; box-shadow: 0 4px 0 #a0620a, 0 6px 10px rgba(0,0,0,0.3); }
  .btn-new:hover { background: linear-gradient(180deg, #ffef88, #f5b23d); }
  .btn-clear { background: linear-gradient(180deg, #ff8888, #cc2222); color: #fff; box-shadow: 0 4px 0 #880000, 0 6px 10px rgba(0,0,0,0.3); }
  .btn-clear:hover { background: linear-gradient(180deg, #ffaaaa, #dd3333); }

  #main { flex: 1; display: flex; width: 100%; overflow: hidden; position: relative; }

  #canvas-wrap {
    flex: 1; display: flex; align-items: center; justify-content: center;
    background: radial-gradient(ellipse at 50% 30%, #2d1060 0%, #0d0520 100%);
    position: relative; overflow: hidden;
  }

  #canvas-wrap::before {
    content: '‚òÖ ‚ú¶ ‚úß ‚òÖ ‚ú¶ ‚úß ‚òÖ ‚ú¶ ‚úß ‚òÖ ‚ú¶ ‚úß ‚òÖ';
    position: absolute; top: 8px;
    color: rgba(255,255,255,0.15); font-size: 10px; letter-spacing: 20px; white-space: nowrap;
  }

  canvas {
    border: 5px solid #7b20c0;
    box-shadow: 0 0 0 2px #ff6ec7, 0 0 0 6px #7b20c0, 0 0 40px rgba(255,110,199,0.3);
    cursor: crosshair; display: block;
  }

  /* Deep navy tray ‚Äî doesn't clash with any crayon */
  #bottom-tray {
    width: 100%;
    background: linear-gradient(180deg, #0b1c3e 0%, #162f5e 40%, #0b1c3e 100%);
    border-top: 4px solid #ff6ec7;
    box-shadow: 0 -4px 0 #2d0060;
    padding: 8px 16px 10px;
    display: flex; flex-direction: column; align-items: center; gap: 6px;
  }

  #tray-label { color: #ffdd44; font-size: 11px; letter-spacing: 4px; text-transform: uppercase; text-shadow: 1px 1px 0 #000; font-family: 'Patrick Hand', cursive; }

  #crayon-row {
    display: flex; gap: 5px; align-items: flex-end;
    flex-wrap: nowrap; overflow-x: auto; padding-bottom: 4px;
  }

  .crayon { width: 28px; height: 76px; cursor: pointer; position: relative; transition: transform 0.15s, filter 0.15s; flex-shrink: 0; }
  .crayon:hover { transform: translateY(-10px); filter: brightness(1.15); z-index: 5; }
  .crayon.selected { transform: translateY(-14px); filter: brightness(1.2) drop-shadow(0 0 8px rgba(255,255,255,0.6)); z-index: 6; }
  .crayon svg { width: 100%; height: 100%; display: block; }

  #selected-info { color: #fff; font-size: 12px; font-family: 'Patrick Hand', cursive; text-shadow: 1px 1px 0 #000; min-height: 16px; letter-spacing: 1px; }

  #loading {
    position: absolute; inset: 0; background: rgba(10,0,30,0.92);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 20; gap: 16px; transition: opacity 0.4s;
  }
  #loading.hidden { opacity: 0; pointer-events: none; }
  .loading-text { color: #ffdd44; font-size: 24px; text-shadow: 2px 2px 0 #2d0060; animation: pulse 0.8s ease-in-out infinite alternate; }
  @keyframes pulse { from { opacity: 0.5; } to { opacity: 1; } }
  .loading-crayons { display: flex; gap: 8px; }
  .lc { width: 16px; height: 48px; border-radius: 3px; animation: bounce 0.6s ease-in-out infinite alternate; }
  .lc:nth-child(2) { animation-delay: 0.1s; }
  .lc:nth-child(3) { animation-delay: 0.2s; }
  .lc:nth-child(4) { animation-delay: 0.3s; }
  .lc:nth-child(5) { animation-delay: 0.4s; }
  @keyframes bounce { from { transform: translateY(0); } to { transform: translateY(-16px); } }

  #tooltip { position: fixed; background: rgba(0,0,0,0.85); color: #fff; font-family: 'Patrick Hand', cursive; font-size: 12px; padding: 4px 10px; border-radius: 4px; pointer-events: none; z-index: 100; display: none; border: 1px solid #ff6ec7; white-space: nowrap; }
</style>
</head>
<body>

<div id="header">
  <div class="logo">
    <span class="logo-icon">üñçÔ∏è</span>
    <div>
      <span class="logo-text">Nature Color Studio</span>
      <span class="logo-sub">Deluxe Edition</span>
    </div>
  </div>
  <div class="header-btns">
    <button class="retro-btn btn-new" onclick="newPicture()">üåø New Picture</button>
    <button class="retro-btn btn-clear" onclick="clearColors()">üóëÔ∏è Clear Colors</button>
  </div>
</div>

<div id="main">
  <div id="canvas-wrap">
    <canvas id="canvas"></canvas>
    <div id="loading">
      <div class="loading-crayons">
        <div class="lc" style="background:#ff4444"></div>
        <div class="lc" style="background:#ff9933"></div>
        <div class="lc" style="background:#ffdd00"></div>
        <div class="lc" style="background:#33bb33"></div>
        <div class="lc" style="background:#3366ff"></div>
      </div>
      <div class="loading-text">Drawing your scene...</div>
    </div>
  </div>
</div>

<div id="bottom-tray">
  <div id="tray-label">‚ú¶ Pick a Crayon ‚ú¶</div>
  <div id="crayon-row"></div>
  <div id="selected-info">Click a crayon to begin coloring!</div>
</div>
<div id="tooltip"></div>

<script>
const CRAYONS = [
  { name: 'Licorice',     hex: '#1a1a1a' },
  { name: 'Night Blue',   hex: '#1c2a6e' },
  { name: 'Royal Purple', hex: '#5b2d8e' },
  { name: 'Plum',         hex: '#8b1a5a' },
  { name: 'Cherry Red',   hex: '#d01010' },
  { name: 'Brick Red',    hex: '#b83a2c' },
  { name: 'Tangerine',    hex: '#e8660a' },
  { name: 'Sunshine',     hex: '#f7d010' },
  { name: 'Lemon Drop',   hex: '#f0f050' },
  { name: 'Grass Green',  hex: '#1e8a1e' },
  { name: 'Fern',         hex: '#4aaa30' },
  { name: 'Mint Leaf',    hex: '#70dd88' },
  { name: 'Cerulean',     hex: '#1a88d8' },
  { name: 'Sky Blue',     hex: '#50b8f0' },
  { name: 'Baby Blue',    hex: '#a0d8f8' },
  { name: 'Aqua',         hex: '#20c8b8' },
  { name: 'Pink Rose',    hex: '#f060a8' },
  { name: 'Cotton Candy', hex: '#f8a8cc' },
  { name: 'Peach',        hex: '#f0b888' },
  { name: 'Tan',          hex: '#c8905a' },
  { name: 'Chestnut',     hex: '#7a3e18' },
  { name: 'Silver',       hex: '#b0b8c8' },
  { name: 'Cloud White',  hex: '#f0f0f0' },
  { name: 'Eraser',       hex: '#ffffff', isEraser: true },
];

function buildCrayons() {
  const row = document.getElementById('crayon-row');
  row.innerHTML = '';
  CRAYONS.forEach((c, i) => {
    const div = document.createElement('div');
    div.className = 'crayon' + (i === 0 ? ' selected' : '');
    div.innerHTML = makeCrayonSVG(c.hex);
    div.addEventListener('click', () => selectCrayon(i));
    div.addEventListener('mouseenter', e => showTooltip(e, c.name));
    div.addEventListener('mouseleave', hideTooltip);
    row.appendChild(div);
  });
}

function makeCrayonSVG(hex) {
  const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
  const L=`rgb(${Math.min(255,r+60)},${Math.min(255,g+60)},${Math.min(255,b+60)})`;
  const D=`rgb(${Math.max(0,r-50)},${Math.max(0,g-50)},${Math.max(0,b-50)})`;
  const T=`rgb(${Math.max(0,r-30)},${Math.max(0,g-30)},${Math.max(0,b-30)})`;
  const id=hex.slice(1);
  return `<svg viewBox="0 0 28 76" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="cg${id}" x1="0" x2="1"><stop offset="0%" stop-color="${D}"/><stop offset="25%" stop-color="${L}"/><stop offset="55%" stop-color="${hex}"/><stop offset="80%" stop-color="${D}"/><stop offset="100%" stop-color="${hex}"/></linearGradient>
    <linearGradient id="wr${id}" x1="0" x2="1"><stop offset="0%" stop-color="rgba(0,0,0,0.25)"/><stop offset="30%" stop-color="rgba(255,255,255,0.18)"/><stop offset="60%" stop-color="rgba(0,0,0,0.1)"/><stop offset="100%" stop-color="rgba(0,0,0,0.22)"/></linearGradient>
  </defs>
  <polygon points="14,0 4,22 24,22" fill="${T}"/>
  <polygon points="14,2 8,22 20,22" fill="${T}"/>
  <rect x="4" y="22" width="20" height="50" rx="2" fill="url(#cg${id})"/>
  <rect x="4" y="22" width="20" height="50" rx="2" fill="url(#wr${id})"/>
  <rect x="4" y="36" width="20" height="14" fill="rgba(255,255,255,0.12)"/>
  <rect x="4" y="36" width="20" height="1" fill="rgba(255,255,255,0.3)"/>
  <rect x="4" y="50" width="20" height="1" fill="rgba(0,0,0,0.2)"/>
  <rect x="8" y="24" width="4" height="44" rx="2" fill="rgba(255,255,255,0.12)"/>
  <rect x="4" y="70" width="20" height="4" rx="1" fill="${D}"/>
</svg>`;
}

let selectedCrayonIdx = 0;
function selectCrayon(i) {
  selectedCrayonIdx = i;
  document.querySelectorAll('.crayon').forEach((el,j) => el.classList.toggle('selected', j===i));
  const c = CRAYONS[i];
  document.getElementById('selected-info').textContent = c.isEraser ? 'üßπ Eraser ‚Äî click to remove color!' : `üñçÔ∏è ${c.name} selected`;
}
function showTooltip(e,name) { const t=document.getElementById('tooltip'); t.textContent=name; t.style.display='block'; t.style.left=(e.clientX+12)+'px'; t.style.top=(e.clientY-28)+'px'; }
function hideTooltip() { document.getElementById('tooltip').style.display='none'; }

// CANVAS
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
let W, H, lineCanvas, lineCtx, colorCanvas, colorCtx;

function initCanvas() {
  const wrap = document.getElementById('canvas-wrap');
  W = Math.min(Math.floor(wrap.clientWidth - 40), 800);
  H = Math.min(Math.floor(wrap.clientHeight - 20), 560);
  canvas.width = W; canvas.height = H;
  lineCanvas = document.createElement('canvas');
  lineCanvas.width = W; lineCanvas.height = H;
  lineCtx = lineCanvas.getContext('2d', { willReadFrequently: true });
  colorCanvas = document.createElement('canvas');
  colorCanvas.width = W; colorCanvas.height = H;
  colorCtx = colorCanvas.getContext('2d', { willReadFrequently: true });
}

function composite() {
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0,0,W,H);
  ctx.drawImage(colorCanvas,0,0);
  ctx.drawImage(lineCanvas,0,0);
}

// SEEDED RNG
let seed = 1;
function reseed() { seed = (Math.random()*99999|0) + 1; }
function sr() { seed = (seed * 1664525 + 1013904223) & 0x7fffffff; return seed / 0x7fffffff; }

// =====================================================
// CORE SHAPE HELPER
// Every shape = white fill + black stroke. This creates
// individual flood-fillable enclosed regions.
// =====================================================
const LW = 2.8;

function S(fn) {
  // "S" for Shape ‚Äî draws a closed, white-filled, black-outlined region
  lineCtx.beginPath();
  fn();
  lineCtx.fillStyle = '#ffffff';
  lineCtx.fill();
  lineCtx.strokeStyle = '#111111';
  lineCtx.lineWidth = LW;
  lineCtx.lineJoin = 'round';
  lineCtx.lineCap = 'round';
  lineCtx.stroke();
}

// =====================================================
// REUSABLE DRAWING PRIMITIVES
// =====================================================

function drawSkyBand(h) {
  S(() => { lineCtx.rect(0, 0, W, h); });
}

function drawGroundBand(y) {
  S(() => { lineCtx.rect(0, y, W, H - y); });
}

function drawHill(x, y, rx, ry) {
  S(() => {
    lineCtx.moveTo(x - rx, y);
    lineCtx.ellipse(x, y, rx, ry, 0, Math.PI, 0, false);
    lineCtx.closePath();
  });
}

// Sun = circle + individual triangular rays
function drawSun(x, y, r) {
  const rays = 10;
  for (let i = 0; i < rays; i++) {
    const a = (i / rays) * Math.PI * 2;
    const a1 = a - 0.2, a2 = a + 0.2;
    S(() => {
      lineCtx.moveTo(x + Math.cos(a) * (r + 24), y + Math.sin(a) * (r + 24));
      lineCtx.lineTo(x + Math.cos(a1) * (r + 4), y + Math.sin(a1) * (r + 4));
      lineCtx.lineTo(x + Math.cos(a2) * (r + 4), y + Math.sin(a2) * (r + 4));
      lineCtx.closePath();
    });
  }
  S(() => { lineCtx.arc(x, y, r, 0, Math.PI * 2); });
}

// Cloud = single smooth closed bezier path ‚Äî no overlapping circles
function drawCloud(x, y) {
  S(() => {
    // A proper cloud silhouette traced as one continuous closed path
    // Starting from bottom-left, going clockwise
    const cx = x, cy = y;
    lineCtx.moveTo(cx, cy + 18);
    // Bottom-left flat curve
    lineCtx.bezierCurveTo(cx - 2, cy + 28, cx + 18, cy + 30, cx + 28, cy + 26);
    // Bottom middle
    lineCtx.bezierCurveTo(cx + 38, cy + 30, cx + 58, cy + 30, cx + 68, cy + 26);
    // Bottom-right
    lineCtx.bezierCurveTo(cx + 80, cy + 30, cx + 100, cy + 26, cx + 100, cy + 14);
    // Right side bump
    lineCtx.bezierCurveTo(cx + 106, cy + 14, cx + 112, cy + 2, cx + 100, cy - 4);
    // Top-right big bump
    lineCtx.bezierCurveTo(cx + 104, cy - 22, cx + 86, cy - 36, cx + 70, cy - 26);
    // Top center bump (tallest)
    lineCtx.bezierCurveTo(cx + 66, cy - 46, cx + 42, cy - 48, cx + 36, cy - 30);
    // Top-left bump
    lineCtx.bezierCurveTo(cx + 26, cy - 44, cx + 4, cy - 38, cx + 4, cy - 20);
    // Left side back down
    lineCtx.bezierCurveTo(cx - 8, cy - 18, cx - 8, cy + 8, cx, cy + 18);
    lineCtx.closePath();
  });
}

// Round tree = trunk (rect) + canopy (circle) ‚Äî 2 separate fillable zones
function drawRoundTree(x, gy, canopyR, trunkH) {
  const tw = canopyR * 0.28;
  S(() => { lineCtx.rect(x - tw / 2, gy - trunkH, tw, trunkH); });
  S(() => { lineCtx.arc(x, gy - trunkH - canopyR * 0.55, canopyR, 0, Math.PI * 2); });
}

// Pine = trunk + 3 separate triangle tiers (4 fillable zones total)
function drawPineTree(x, gy, h) {
  const tw = h * 0.08, trunkH = h * 0.2;
  S(() => { lineCtx.rect(x - tw / 2, gy - trunkH, tw, trunkH); });
  for (let t = 0; t < 3; t++) {
    const ty = gy - trunkH - t * (h * 0.26);
    const tw2 = h * (0.36 - t * 0.06);
    S(() => {
      lineCtx.moveTo(x, ty - h * 0.26);
      lineCtx.lineTo(x + tw2, ty);
      lineCtx.lineTo(x - tw2, ty);
      lineCtx.closePath();
    });
  }
}

// Flower = stem + individual petals + center (all separate)
function drawFlower(x, y, r, numP) {
  numP = numP || 6;
  // Stem
  S(() => {
    lineCtx.moveTo(x - 3, y + r * 0.55);
    lineCtx.lineTo(x + 3, y + r * 0.55);
    lineCtx.lineTo(x + 3, y + r * 0.55 + 34);
    lineCtx.lineTo(x - 3, y + r * 0.55 + 34);
    lineCtx.closePath();
  });
  // Each petal = its own ellipse
  for (let i = 0; i < numP; i++) {
    const a = (i / numP) * Math.PI * 2;
    S(() => { lineCtx.ellipse(x + Math.cos(a)*r*0.72, y + Math.sin(a)*r*0.72, r*0.4, r*0.26, a, 0, Math.PI*2); });
  }
  // Center
  S(() => { lineCtx.arc(x, y, r * 0.34, 0, Math.PI * 2); });
}

// Butterfly = 4 wings (teardrop shapes) + body (5 fillable areas)
function drawButterfly(x, y, sz) {
  S(() => { lineCtx.ellipse(x - sz*0.52, y - sz*0.28, sz*0.46, sz*0.32, -0.4, 0, Math.PI*2); });
  S(() => { lineCtx.ellipse(x + sz*0.52, y - sz*0.28, sz*0.46, sz*0.32,  0.4, 0, Math.PI*2); });
  S(() => { lineCtx.ellipse(x - sz*0.36, y + sz*0.24, sz*0.3,  sz*0.2,   0.3, 0, Math.PI*2); });
  S(() => { lineCtx.ellipse(x + sz*0.36, y + sz*0.24, sz*0.3,  sz*0.2,  -0.3, 0, Math.PI*2); });
  S(() => { lineCtx.ellipse(x, y, sz*0.1, sz*0.48, 0, 0, Math.PI*2); });
}

// Bird = 2 closed teardrop wings (each independently fillable)
function drawBird(x, y, sz) {
  S(() => {
    lineCtx.moveTo(x, y);
    lineCtx.quadraticCurveTo(x - sz*0.6, y - sz*0.85, x - sz*1.1, y);
    lineCtx.quadraticCurveTo(x - sz*0.6, y + sz*0.28, x, y);
    lineCtx.closePath();
  });
  S(() => {
    lineCtx.moveTo(x, y);
    lineCtx.quadraticCurveTo(x + sz*0.6, y - sz*0.85, x + sz*1.1, y);
    lineCtx.quadraticCurveTo(x + sz*0.6, y + sz*0.28, x, y);
    lineCtx.closePath();
  });
}

// Rainbow = 6 arc bands (each its own region)
function drawRainbow(cx, cy, r0, bw) {
  for (let i = 0; i < 6; i++) {
    const r1 = r0 + i*bw, r2 = r1 + bw;
    S(() => {
      lineCtx.arc(cx, cy, r2, Math.PI, 0, false);
      lineCtx.arc(cx, cy, r1, 0, Math.PI, true);
      lineCtx.closePath();
    });
  }
}

// Mountain = closed polygon
function drawMountain(x1, x2, peakX, peakY, gy) {
  S(() => {
    lineCtx.moveTo(x1, gy);
    lineCtx.lineTo(peakX, peakY);
    lineCtx.lineTo(x2, gy);
    lineCtx.closePath();
  });
}

// Snow cap = small triangle on top of mountain peak
function drawSnowCap(px, py, w) {
  S(() => {
    lineCtx.moveTo(px, py);
    lineCtx.lineTo(px - w, py + w * 1.3);
    lineCtx.lineTo(px + w, py + w * 1.3);
    lineCtx.closePath();
  });
}

// Rabbit = body + head + 2 ears + tail + eye
function drawRabbit(x, gy) {
  S(() => { lineCtx.ellipse(x, gy - 24, 20, 26, 0, 0, Math.PI*2); });
  S(() => { lineCtx.ellipse(x + 6, gy - 60, 16, 18, 0.2, 0, Math.PI*2); });
  S(() => { lineCtx.ellipse(x - 3, gy - 86, 6, 18, -0.2, 0, Math.PI*2); });
  S(() => { lineCtx.ellipse(x + 12, gy - 84, 6, 18,  0.2, 0, Math.PI*2); });
  S(() => { lineCtx.arc(x - 19, gy - 26, 8, 0, Math.PI*2); });
  S(() => { lineCtx.arc(x + 10, gy - 62, 3, 0, Math.PI*2); });
}

// Mushroom = stem (rect) + cap (semicircle) + 2 dots
function drawMushroom(x, y, sz) {
  S(() => { lineCtx.rect(x - sz*0.18, y - sz*0.42, sz*0.36, sz*0.42); });
  S(() => {
    lineCtx.arc(x, y - sz*0.42, sz*0.5, Math.PI, 0);
    lineCtx.closePath();
  });
  S(() => { lineCtx.arc(x - sz*0.14, y - sz*0.6, sz*0.09, 0, Math.PI*2); });
  S(() => { lineCtx.arc(x + sz*0.18, y - sz*0.55, sz*0.09, 0, Math.PI*2); });
}

// Crab = body + 2 claws + legs + eyes
function drawCrab(cx, cy) {
  S(() => { lineCtx.ellipse(cx, cy, 26, 16, 0, 0, Math.PI*2); });
  S(() => { lineCtx.ellipse(cx - 48, cy - 16, 12, 9, 0.4, 0, Math.PI*2); });
  S(() => { lineCtx.ellipse(cx + 48, cy - 16, 12, 9, -0.4, 0, Math.PI*2); });
  // Arm segments (fat closed quads)
  S(() => { lineCtx.moveTo(cx-24,cy-4); lineCtx.lineTo(cx-32,cy-14); lineCtx.lineTo(cx-38,cy-18); lineCtx.lineTo(cx-30,cy-8); lineCtx.closePath(); });
  S(() => { lineCtx.moveTo(cx+24,cy-4); lineCtx.lineTo(cx+32,cy-14); lineCtx.lineTo(cx+38,cy-18); lineCtx.lineTo(cx+30,cy-8); lineCtx.closePath(); });
  for (let j = 0; j < 3; j++) {
    S(() => { const lx=cx-8-j*6; lineCtx.moveTo(lx,cy+12); lineCtx.lineTo(lx-4,cy+12); lineCtx.lineTo(lx-10-j*4,cy+30); lineCtx.lineTo(lx-6-j*4,cy+30); lineCtx.closePath(); });
    S(() => { const lx=cx+8+j*6; lineCtx.moveTo(lx,cy+12); lineCtx.lineTo(lx+4,cy+12); lineCtx.lineTo(lx+10+j*4,cy+30); lineCtx.lineTo(lx+6+j*4,cy+30); lineCtx.closePath(); });
  }
  S(() => { lineCtx.arc(cx-10,cy-13,4,0,Math.PI*2); });
  S(() => { lineCtx.arc(cx+10,cy-13,4,0,Math.PI*2); });
}

// Starfish = 5-pointed star polygon
function drawStarfish(x, y, r) {
  S(() => {
    for (let i = 0; i < 5; i++) {
      const a = (i/5)*Math.PI*2 - Math.PI/2;
      const ai = a + Math.PI/5;
      if (i===0) lineCtx.moveTo(x+Math.cos(a)*r, y+Math.sin(a)*r);
      else lineCtx.lineTo(x+Math.cos(a)*r, y+Math.sin(a)*r);
      lineCtx.lineTo(x+Math.cos(ai)*r*0.42, y+Math.sin(ai)*r*0.42);
    }
    lineCtx.closePath();
  });
}

// Shell = half-circle + 2 nested inner arcs (3 separate zones)
function drawShell(x, y, r) {
  S(() => { lineCtx.moveTo(x-r,y); lineCtx.arc(x,y,r,Math.PI,0); lineCtx.closePath(); });
  S(() => { lineCtx.moveTo(x-r*0.65,y); lineCtx.arc(x,y,r*0.65,Math.PI,0); lineCtx.closePath(); });
  S(() => { lineCtx.moveTo(x-r*0.3,y); lineCtx.arc(x,y,r*0.3,Math.PI,0); lineCtx.closePath(); });
}

// Palm tree = curved trunk polygon + leaf fronds
function drawPalmTree(x, gy) {
  const h = 115;
  S(() => {
    lineCtx.moveTo(x - 8, gy);
    lineCtx.quadraticCurveTo(x - 14, gy - h*0.5, x + 8, gy - h);
    lineCtx.lineTo(x + 16, gy - h);
    lineCtx.quadraticCurveTo(x + 4, gy - h*0.5, x + 8, gy);
    lineCtx.closePath();
  });
  const bx = x + 10, by = gy - h;
  for (let l = 0; l < 5; l++) {
    const a = -Math.PI*0.72 + l*Math.PI*0.36;
    S(() => {
      lineCtx.moveTo(bx, by);
      lineCtx.quadraticCurveTo(bx+Math.cos(a)*36+Math.cos(a+Math.PI/2)*16, by+Math.sin(a)*36+Math.sin(a+Math.PI/2)*16, bx+Math.cos(a)*72, by+Math.sin(a)*50);
      lineCtx.quadraticCurveTo(bx+Math.cos(a)*36-Math.cos(a+Math.PI/2)*16, by+Math.sin(a)*36-Math.sin(a+Math.PI/2)*16, bx, by);
      lineCtx.closePath();
    });
  }
}

// Sunflower = stem + leaf + petals + center
function drawSunflower(x, gy, sz) {
  const sh = sz * 2.7;
  S(() => { lineCtx.moveTo(x-4,gy); lineCtx.lineTo(x+4,gy); lineCtx.lineTo(x+4,gy-sh); lineCtx.lineTo(x-4,gy-sh); lineCtx.closePath(); });
  S(() => { lineCtx.ellipse(x+22, gy-sh*0.55, 22, 10, 0.5, 0, Math.PI*2); });
  const petals = 12;
  for (let i = 0; i < petals; i++) {
    const a = (i/petals)*Math.PI*2;
    S(() => { lineCtx.ellipse(x+Math.cos(a)*sz*0.72, gy-sh+Math.sin(a)*sz*0.72, sz*0.28, sz*0.16, a, 0, Math.PI*2); });
  }
  S(() => { lineCtx.arc(x, gy-sh, sz*0.38, 0, Math.PI*2); });
}

// Fence picket = pointed-top closed rectangle
function drawPicket(x, y, w, h) {
  S(() => {
    lineCtx.moveTo(x + w/2, y - 14);
    lineCtx.lineTo(x, y);
    lineCtx.lineTo(x, y + h);
    lineCtx.lineTo(x + w, y + h);
    lineCtx.lineTo(x + w, y);
    lineCtx.closePath();
  });
}

// Bee = body + stripe + 2 wings
function drawBee(x, y) {
  S(() => { lineCtx.ellipse(x, y, 11, 7, 0, 0, Math.PI*2); });
  S(() => { lineCtx.moveTo(x-2,y-7); lineCtx.lineTo(x+3,y-7); lineCtx.lineTo(x+3,y+7); lineCtx.lineTo(x-2,y+7); lineCtx.closePath(); });
  S(() => { lineCtx.ellipse(x-4, y-11, 8, 4, -0.3, 0, Math.PI*2); });
  S(() => { lineCtx.ellipse(x+6, y-11, 8, 4,  0.3, 0, Math.PI*2); });
}

// Watering can = body + handle + spout
function drawWateringCan(x, y) {
  S(() => { lineCtx.rect(x, y-34, 38, 28); });
  S(() => {
    lineCtx.moveTo(x+38,y-28); lineCtx.quadraticCurveTo(x+62,y-38,x+60,y-14);
    lineCtx.lineTo(x+54,y-14); lineCtx.quadraticCurveTo(x+56,y-32,x+34,y-24);
    lineCtx.closePath();
  });
  S(() => {
    lineCtx.moveTo(x+8,y-34); lineCtx.quadraticCurveTo(x+12,y-52,x+28,y-50);
    lineCtx.lineTo(x+30,y-44); lineCtx.quadraticCurveTo(x+16,y-44,x+14,y-32);
    lineCtx.closePath();
  });
}

// Wave band = closed strip with wavy top edge
function drawWaveBand(y, bh) {
  S(() => {
    lineCtx.moveTo(0, y);
    for (let x = 0; x <= W + 50; x += 52) {
      lineCtx.quadraticCurveTo(x + 26, y - 16, x + 52, y);
    }
    lineCtx.lineTo(W, y + bh); lineCtx.lineTo(0, y + bh);
    lineCtx.closePath();
  });
}

// =====================================================
// SCENES
// =====================================================
function generateScene() {
  reseed();
  lineCtx.clearRect(0,0,W,H);
  colorCtx.clearRect(0,0,W,H);
  const n = Math.floor(sr() * 5);
  [drawForestScene, drawBeachScene, drawMeadowScene, drawMountainScene, drawGardenScene][n]();
  composite();
}

function drawForestScene() {
  const gy = H * 0.65;
  drawSkyBand(gy);
  drawGroundBand(gy);
  drawSun(W*0.85, H*0.1, 38);
  drawCloud(W*0.04, 22);
  drawCloud(W*0.42, 12);
  drawHill(W*0.2, gy+8, 200, 68);
  drawHill(W*0.78, gy+8, 165, 55);
  [0.1, 0.28, 0.5, 0.7, 0.88].forEach(p => {
    const tx = W*p + (sr()-0.5)*25;
    sr() > 0.45 ? drawRoundTree(tx, gy, 52+sr()*28, 52+sr()*18) : drawPineTree(tx, gy, 100+sr()*45);
  });
  drawMushroom(W*0.2, gy, 32); drawMushroom(W*0.62, gy, 26);
  [0.06,0.17,0.29,0.4,0.52,0.63,0.75].forEach(p => drawFlower(W*p, gy+8+sr()*28, 14+sr()*8, 6));
  drawButterfly(W*0.34, H*0.29, 22); drawButterfly(W*0.6, H*0.18, 19);
  drawBird(W*0.25, H*0.11, 13); drawBird(W*0.55, H*0.07, 10); drawBird(W*0.72, H*0.14, 11);
}

function drawBeachScene() {
  const gy = H * 0.6;
  const wY = H * 0.48;
  drawSkyBand(wY);
  drawWaveBand(wY, (gy-wY)*0.48);
  drawWaveBand(wY+(gy-wY)*0.44, (gy-wY)*0.56);
  drawGroundBand(gy);
  drawSun(W*0.12, H*0.1, 40);
  drawCloud(W*0.38, 18); drawCloud(W*0.66, 8);
  drawBird(W*0.28, H*0.08, 11); drawBird(W*0.5, H*0.05, 9); drawBird(W*0.72, H*0.1, 10);
  drawPalmTree(W*0.78, gy);
  drawCrab(W*0.3, gy+28);
  drawStarfish(W*0.55, gy+20, 20); drawStarfish(W*0.16, gy+36, 15);
  drawShell(W*0.44, gy+28, 18); drawShell(W*0.68, gy+22, 14); drawShell(W*0.08, gy+20, 16);
  drawButterfly(W*0.5, H*0.3, 20);
}

function drawMeadowScene() {
  const gy = H * 0.63;
  drawSkyBand(gy);
  drawGroundBand(gy);
  drawSun(W*0.5, H*0.07, 46);
  drawCloud(W*0.07, 18); drawCloud(W*0.56, 26);
  drawHill(W*0.16, gy+12, 240, 85); drawHill(W*0.84, gy+12, 190, 72);
  drawRainbow(W*0.76, gy+18, 82, 14);
  [0.05,0.15,0.26,0.36,0.46,0.57,0.67,0.78,0.88,0.96].forEach(p =>
    drawFlower(W*p, gy+8+sr()*26, 16+sr()*8, 6));
  drawRabbit(W*0.36, gy);
  drawButterfly(W*0.55, H*0.22, 24); drawButterfly(W*0.18, H*0.35, 19); drawButterfly(W*0.78, H*0.28, 21);
  drawBird(W*0.42, H*0.08, 12); drawBird(W*0.62, H*0.06, 10);
  drawRoundTree(W*0.06, gy, 48, 48); drawRoundTree(W*0.94, gy, 46, 46);
}

function drawMountainScene() {
  const gy = H * 0.63;
  drawSkyBand(gy);
  drawGroundBand(gy);
  drawSun(W*0.88, H*0.07, 36);
  drawCloud(W*0.1, 28); drawCloud(W*0.44, 16);
  const mts = [{cx:W*0.18,py:H*0.2,w:200},{cx:W*0.44,py:H*0.1,w:260},{cx:W*0.68,py:H*0.19,w:210},{cx:W*0.9,py:H*0.27,w:180}];
  mts.forEach(m => {
    drawMountain(m.cx - m.w/2, m.cx + m.w/2, m.cx, m.py, gy);
    drawSnowCap(m.cx, m.py, 28);
  });
  drawPineTree(W*0.08, gy, 95); drawPineTree(W*0.2, gy, 110); drawPineTree(W*0.76, gy, 100); drawPineTree(W*0.9, gy, 88);
  S(() => { lineCtx.ellipse(W*0.5, gy+(H-gy)*0.52, W*0.22, (H-gy)*0.22, 0, 0, Math.PI*2); });
  [0.1,0.22,0.35,0.47,0.6,0.7,0.82].forEach(p => drawFlower(W*p, gy+12+sr()*18, 12+sr()*6, 5));
  drawBird(W*0.48, H*0.15, 14); drawBird(W*0.32, H*0.1, 10); drawBird(W*0.62, H*0.09, 11);
}

function drawGardenScene() {
  const gy = H * 0.66;
  drawSkyBand(gy);
  drawGroundBand(gy);
  drawSun(W*0.16, H*0.1, 38);
  drawCloud(W*0.47, 20); drawCloud(W*0.75, 12);
  for (let fx = 20; fx < W - 20; fx += 44) drawPicket(fx, gy-52, 20, 52);
  [0.1, 0.28, 0.48, 0.67, 0.85].forEach(p => drawSunflower(W*p+(sr()-0.5)*18, gy, 22+sr()*10));
  drawBee(W*0.2, H*0.24); drawBee(W*0.45, H*0.17); drawBee(W*0.72, H*0.3);
  [0.06,0.18,0.36,0.54,0.72,0.9].forEach(p => drawFlower(W*p, gy+14+sr()*18, 10+sr()*6, 5));
  drawButterfly(W*0.38, H*0.2, 21); drawButterfly(W*0.6, H*0.35, 18);
  drawWateringCan(W*0.03, gy-8);
  drawBird(W*0.5, H*0.07, 11); drawBird(W*0.68, H*0.1, 9);
}

// =====================================================
// FLOOD FILL
// =====================================================
function floodFill(startX, startY, fillHex) {
  const imageData = colorCtx.getImageData(0,0,W,H);
  const data = imageData.data;
  const lineData = lineCtx.getImageData(0,0,W,H).data;
  const idx = (x,y) => (y*W+x)*4;
  const si = idx(startX,startY);
  const fr=parseInt(fillHex.slice(1,3),16), fg=parseInt(fillHex.slice(3,5),16), fb=parseInt(fillHex.slice(5,7),16);
  if (lineData[si+3]>128 && lineData[si]<80) return;
  const tR=data[si], tG=data[si+1], tB=data[si+2], tA=data[si+3];
  if (tR===fr && tG===fg && tB===fb && tA===255) return;
  function isLine(x,y) { const i=idx(x,y); return lineData[i+3]>128 && lineData[i]<80; }
  function match(i) { return data[i]===tR && data[i+1]===tG && data[i+2]===tB && data[i+3]===tA; }
  const queue=[startX,startY];
  const visited=new Uint8Array(W*H);
  visited[startY*W+startX]=1;
  let head=0;
  while (head<queue.length) {
    const x=queue[head++], y=queue[head++];
    if (isLine(x,y)) continue;
    const i=idx(x,y);
    data[i]=fr; data[i+1]=fg; data[i+2]=fb; data[i+3]=255;
    [[x+1,y],[x-1,y],[x,y+1],[x,y-1]].forEach(([nx,ny]) => {
      if (nx<0||ny<0||nx>=W||ny>=H) return;
      const vi=ny*W+nx;
      if (visited[vi]) return;
      visited[vi]=1;
      if (!isLine(nx,ny) && match(idx(nx,ny))) queue.push(nx,ny);
    });
  }
  colorCtx.putImageData(imageData,0,0);
  composite();
}

// =====================================================
// EVENTS & INIT
// =====================================================
canvas.addEventListener('click', e => {
  const rect=canvas.getBoundingClientRect();
  const x=Math.floor((e.clientX-rect.left)*(W/rect.width));
  const y=Math.floor((e.clientY-rect.top)*(H/rect.height));
  if (x<0||y<0||x>=W||y>=H) return;
  const fc=CRAYONS[selectedCrayonIdx].isEraser?'#ffffff':CRAYONS[selectedCrayonIdx].hex;
  canvas.style.cursor='wait';
  setTimeout(()=>{ floodFill(x,y,fc); canvas.style.cursor='crosshair'; },10);
});

function newPicture() {
  document.getElementById('loading').classList.remove('hidden');
  colorCtx.clearRect(0,0,W,H);
  setTimeout(()=>{
    generateScene();
    setTimeout(()=>document.getElementById('loading').classList.add('hidden'),300);
  },200);
}
function clearColors() { colorCtx.clearRect(0,0,W,H); composite(); }

window.addEventListener('load',()=>{ buildCrayons(); initCanvas(); selectCrayon(0); newPicture(); });
window.addEventListener('resize',()=>{ initCanvas(); generateScene(); });
</script>
</body>
</html>
